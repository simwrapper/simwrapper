<template lang="pug">
.transit-viz(:class="{'hide-thumbnail': !thumbnail}")

  //- @mousemove.stop
  .main-layout(v-if="!thumbnail"
    @mousemove="dividerDragging"
    @mouseup="dividerDragEnd"
  )
    .dragger(v-show="showLegend"
      @mousedown="dividerDragStart"
      @mouseup="dividerDragEnd"
      @mousemove.stop="dividerDragging"
    )

    .new-rightside-info-panel(v-show="showLegend" :style="{width: `${legendSectionWidth}px`}")

      p(style="margin-top: 0.25rem")
        b TRANSIT LINES AND ROUTES

      .panel-item(v-if="metrics.length > 1")
        .metric-buttons
          button.button.is-small.metric-button(
            v-for="metric,i in metrics" :key="metric.field"
            :style="{'color': activeMetric===metric.field ? 'white' : buttonColors[i], 'border': `1px solid ${buttonColors[i]}`, 'background-color': activeMetric===metric.field ? buttonColors[i] : isDarkMode ? '#333':'white'}"
            @click="handleClickedMetric(metric)") {{ $i18n.locale === 'de' ? metric.name_de : metric.name_en }}

      b-input.searchbox(
        v-model="searchText" style="padding: 0.5rem 0.5rem 1rem 0" size="is-small" placeholder="Search..."
      )

      p(v-if="!routesOnLink.length" style="font-size: 0.9rem") Select a link to view its routes.

      .link-summary.flex-col(v-if="summaryStats.departures")
          p: b LINK SUMMARY
          .indent.flex-col(style="margin-top: 0.5rem; margin-left: 0.5rem; font-size: 0.9rem")
            p Departures: {{ summaryStats.departures }}
            p(v-if="cfDemand1") Passengers: {{ summaryStats.pax }}
            p(v-if="cfDemand1") Load factor: {{ summaryStats.loadfac }}

      p(v-if="activeTransitLines.length" style="margin-bottom: 0.25rem"): b LINES AND ROUTES

      .transit-lines.flex1
        route-drop-down(v-for="line in Object.values(transitLines)" :key="line.id"
          :line="line"
          :isChecked="false"
          color="#06f"
        )

      .panel-items
        //- .transit-lines
        //-   .transit-line.flex-col(v-for="line in activeTransitLines" :key="line.id")

        //-     .line-header(@click="toggleTransitLine(line)")
        //-       p {{ line.id }}
        //-       .stats.flex-row
        //-         .stat {{ line.stats.departures }} dep
        //-         .stat(v-if="cfDemand1") {{ line.stats.pax }} pax
        //-         .stat(v-if="cfDemand1") {{ line.stats.cap }} cap

        //-     .route-list-items.flex-col(v-if="line.isOpen")
        //-       .route.flex-col(v-for="route in line.routes" :key="route.id"
        //-         :class="{highlightedRoute: selectedRouteIds.includes(route.id)}"
        //-         @click="showRouteDetails(route.id, line.routes.length)"
        //-       )
        //-         .route-title {{route.id}}
        //-         .detailed-route-data
        //-             .stat {{ route.departures }} dep
        //-             .stat(v-if="route.pax") {{ route.pax }} pax
        //-             .stat(v-if="route.pax") {{ route.cap }} cap
        //-         .col {{route.firstDeparture}} — {{route.lastDeparture}}

      b-slider.pie-slider(type="is-danger" :tooltip="false" size="is-small"  v-model="pieSlider" @input="updatePieSlider")

      legend-box.legend(v-if="!thumbnail"
        :rows="legendRows"
      )

    .map-container(:class="{'hide-thumbnail': !thumbnail }" oncontextmenu="return false")

      transit-layers.map-styles(v-if="transitLinks?.features.length"
        :viewId="viewId"
        :links="transitLinks"
        :selectedFeatures="selectedFeatures"
        :stopMarkers="stopMarkers"
        :handleClickEvent="handleMapClick"
        :pieSlider="pieSlider"
      )
        //- .stop-html(v-if="stopHTML.html" v-html="stopHTML.html"
        //-   :style="{left: stopHTML.x + 'px', top: stopHTML.y+'px'}"
        //- )

      zoom-buttons
      //- drawing-tool(v-if="!thumbnail")

      .status-corner(v-if="loadingText")
        p {{ loadingText }}
        b-progress.load-progress(v-if="loadProgress > 0"
          :value="loadProgress" :rounded="false" type='is-success')

</template>

<script lang="ts">
const i18n = {
  messages: {
    en: { metrics: 'Metrics', viewer: 'Transit Network' },
    de: { metrics: 'Metrics', viewer: 'ÖV Netzwerk' },
  },
}

import { defineComponent } from 'vue'
import type { PropType } from 'vue'

import * as turf from '@turf/turf'
import avro from '@/js/avro'
import colormap from 'colormap'
import crossfilter from 'crossfilter2'
import { debounce } from 'debounce'
import Papa from '@simwrapper/papaparse'
import yaml from 'yaml'
import match from 'micromatch'
import naturalSort from 'javascript-natural-sort'

import globalStore from '@/store'
import CollapsiblePanel from '@/components/CollapsiblePanel.vue'
import HTTPFileSystem from '@/js/HTTPFileSystem'
import LeftDataPanel from '@/components/LeftDataPanel.vue'
import { Network, NetworkInputs, NetworkNode, TransitLine, RouteDetails } from './Interfaces'
import NewXmlFetcher from '@/workers/NewXmlFetcher.worker?worker'
import TransitSupplyWorker from './TransitSupplyHelper.worker?worker'
import DrawingTool from '@/components/DrawingTool/DrawingTool.vue'
import ZoomButtons from '@/components/ZoomButtons.vue'
import DashboardDataManager from '@/js/DashboardDataManager'
import TransitLayers from './TransitLayers'
import LegendBox from './LegendBox.vue'
import RouteDropDown from './RouteDropDown.vue'

import {
  FileSystem,
  FileSystemConfig,
  ColorScheme,
  VisualizationPlugin,
  REACT_VIEW_HANDLES,
} from '@/Globals'

import GzipWorker from '@/workers/GzipFetcher.worker?worker'

const DEFAULT_PROJECTION = 'EPSG:31468' // 31468' // 2048'

const COLOR_CATEGORIES = 10
const SHOW_STOPS_AT_ZOOM_LEVEL = 11

const DEFAULT_ROUTE_COLORS = [
  // ---------------------------------------------------
  // GTFS codes first, they are most accurate.
  {
    match: {
      gtfsRouteType: [3, 700, 701, 702, 703, 704],
    },
    color: '#95276E',
    label: 'Bus (GTFS)',
  },
  {
    match: {
      gtfsRouteType: [109],
    },
    color: '#408335',
    label: 'S-Bahn (GTFS)',
  },
  {
    match: {
      gtfsRouteType: [401, 402],
    },
    color: '#115D91',
    label: 'U-Bahn (GTFS)',
  },
  {
    match: {
      gtfsRouteType: [0, 3, 900, 901, 902, 903, 904, 905, 906],
    },
    color: '#BE1414',
    label: 'Tram (GTFS)',
  },
  {
    match: {
      gtfsRouteType: [4, 1000, 1200],
    },
    color: '#0480c1',
    label: 'Ferry (GTFS)',
  },
  // ---------------------------------------------------
  // MATSim transportMode and string-id next; less accurate but consistent.
  {
    match: {
      transportMode: ['rail', 'subway'],
      id: 'U*',
    },
    color: '#115D91',
    label: 'U-Bahn',
  },
  {
    match: {
      transportMode: 'rail',
      id: 'S*',
    },
    color: '#408335',
    label: 'S-Bahn',
  },
  {
    match: {
      transportMode: 'ferry',
    },
    color: '#0480c1',
    label: 'Ferry',
  },
  {
    match: {
      transportMode: 'tram',
    },
    color: '#9E1444',
    label: 'Tram',
  },
  {
    match: { transportMode: 'pt' },
    color: '#05c',
    label: 'Public Transport',
  },
  {
    match: {
      transportMode: 'rail',
    },
    color: '#EC0016 ',
    label: 'Train',
  },
  {
    match: { transportMode: 'train' },
    color: '#0a0',
    label: 'Rail',
  },
  {
    match: {
      transportMode: 'bus',
    },
    color: '#95276E',
    label: 'Bus',
  },
  {
    match: { id: '**' },
    color: '#aae',
    label: 'Other',
  },
] as { match: any; color: string; label: string; hide: boolean }[]

class Departure {
  public total: number = 0
  public routes: Set<string> = new Set()
}

const MyComponent = defineComponent({
  name: 'TransitViewer',
  i18n,
  components: {
    CollapsiblePanel,
    LeftDataPanel,
    LegendBox,
    DrawingTool,
    ZoomButtons,
    TransitLayers,
    RouteDropDown,
  },

  props: {
    root: { type: String, required: true },
    subfolder: { type: String, required: true },
    yamlConfig: String,
    config: { type: Object as any },
    thumbnail: Boolean,
    datamanager: { type: Object as PropType<DashboardDataManager> },
  },

  data() {
    const metrics = [{ field: 'departures', name_en: 'Departures', name_de: 'Abfahrten' }]

    return {
      viewId: Math.floor(1e12 * Math.random()),
      loadProgress: 0,
      loadSteps: 0,
      totalLoadSteps: 7,
      searchText: '',
      //drag
      isDraggingDivider: 0,
      dragStartWidth: 250,
      legendSectionWidth: 250,
      showLegend: true,
      //
      stopHTML: { html: '', x: 0, y: 0 },
      buttonColors: ['#5E8AAE', '#BF7230', '#269367', '#9C439C'],
      metrics: metrics,
      activeMetric: metrics[0].field as any,
      activeRoutes: [] as RouteDetails[],
      vizDetails: {
        transitSchedule: '',
        network: '',
        demand: '',
        projection: '',
        title: '',
        description: '',
        customRouteTypes: [] as { match: any; color: string; label: string; hide: boolean }[],
      },
      // DataManager might be passed in from the dashboard; or we might be
      // in single-view mode, in which case we need to create one for ourselves
      myDataManager: this.datamanager || new DashboardDataManager(this.root, this.subfolder),
      debounceHandleSearchText: {} as any,

      myState: {
        subfolder: '',
        yamlConfig: '',
        thumbnail: true,
      },

      avroNetwork: null as any,
      isDarkMode: globalStore.state.isDarkMode,
      isMapMoving: false,
      isHighlightingLink: false,
      loadingText: 'MATSim Transit Inspector',
      projection: DEFAULT_PROJECTION,
      routesOnLink: [] as RouteDetails[],
      selectedLinkId: '',
      selectedRouteIds: [] as string[],
      selectedTransitLine: '',
      selectedFeatures: [] as any[],
      summaryStats: { departures: 0, pax: 0, loadfac: 0 },
      stopMarkers: [] as any[],
      _departures: {} as { [linkID: string]: Departure },
      _mapExtentXYXY: null as any,
      _maximum: -Infinity,
      _network: {} as Network,
      transitLinks: { type: 'FeatureCollection', features: [] } as any, // GeoJSON.FeatureCollection,
      transitLinkOffset: {} as { [linkId: string]: number },
      _geoTransitLinks: null as any,
      _routeData: {} as { [index: string]: RouteDetails },
      _stopFacilities: {} as { [index: string]: NetworkNode },
      transitLines: {} as { [index: string]: TransitLine },
      _roadFetcher: {} as any,
      _transitFetcher: {} as any,
      _transitHelper: {} as any,

      pieSlider: 30,

      resolvers: {} as { [id: number]: any },
      resolverId: 0,
      xmlWorker: null as null | Worker,
      cfDemand1: null as crossfilter.Crossfilter<any> | null,
      cfDemand2: null as crossfilter.Crossfilter<any> | null,
      cfDemandLink1: null as crossfilter.Dimension<any, any> | null,
      cfDemandLink2: null as crossfilter.Dimension<any, any> | null,
      cfDemandStop1: null as crossfilter.Dimension<any, any> | null,
      cfDemandStop2: null as crossfilter.Dimension<any, any> | null,

      stopLevelDemand: {} as { [id: string]: { b: number; a: number } },

      hoverWait: false,
      routeColors: [] as { match: any; color: string; label: string; hide: boolean }[],
      usedLabels: [] as string[],
    }
  },

  computed: {
    fileApi(): HTTPFileSystem {
      return new HTTPFileSystem(this.fileSystem, globalStore)
    },

    fileSystem(): FileSystemConfig {
      const svnProject: FileSystemConfig[] = this.$store.state.svnProjects.filter(
        (a: FileSystemConfig) => a.slug === this.root
      )
      if (svnProject.length === 0) {
        console.log('no such project')
        throw Error
      }
      return svnProject[0]
    },

    activeTransitLines() {
      const lines = {} as {
        [id: string]: { id: string; routes: RouteDetails[]; isOpen: boolean; stats: any }
      }

      this.routesOnLink.forEach(route => {
        if (!(route.lineId in lines)) {
          lines[route.lineId] = {
            id: route.lineId,
            routes: [],
            isOpen: false,
            stats: {
              departures: 0,
              pax: 0,
              cap: 0,
            },
          }
        }
        lines[route.lineId].routes.push(route)
      })

      // fetch demand data for these links
      const demandLookup = {} as { [routeId: string]: any[] }

      this.cfDemandStop1?.filterAll()
      this.cfDemandStop2?.filterAll()

      this.cfDemandLink1?.filter(this.selectedLinkId)
      let demandData = this.cfDemand1?.allFiltered()
      if (demandData) {
        demandData.forEach(row => {
          if (!(row.transitRoute in demandLookup)) demandLookup[row.transitRoute] = []
          demandLookup[row.transitRoute].push(row)
        })
      }
      this.cfDemandLink2?.filter(this.selectedLinkId)
      demandData = this.cfDemand2?.allFiltered()
      if (demandData) {
        demandData.forEach(row => {
          if (!(row.transitRoute in demandLookup)) demandLookup[row.transitRoute] = []
          demandLookup[row.transitRoute].push(row)
        })
      }

      // sort the routes
      Object.values(lines).forEach(line => {
        // frequentiest routes first
        line.routes.sort((a, b) => (a.departures < b.departures ? 1 : -1)) // naturalSort(a.id, b.id))

        // statistics
        line.routes.forEach(route => {
          route.pax = 0
          route.cap = 0
          line.stats.departures += route.departures
          const routeRuns = demandLookup[route.id]
          if (routeRuns) {
            const pax = routeRuns.reduce((a, b) => {
              return a + b.passengersAtArrival
            }, 0)
            line.stats.pax += pax
            route.pax += pax

            const cap = routeRuns.reduce((a, b) => {
              return a + b.totalVehicleCapacity
            }, 0)
            line.stats.cap += cap
            route.cap += cap
          }
        })
      })

      // sort the lines
      const rows = Object.values(lines).sort((a, b) => naturalSort(a.id, b.id))
      return rows
    },

    legendRows(): string[][] {
      return this.routeColors
        .filter(r => this.usedLabels.includes(r.label))
        .map(r => [r.color, r.label])
    },
  },

  watch: {
    '$store.state.viewState'() {
      if (!REACT_VIEW_HANDLES[this.viewId]) return
      REACT_VIEW_HANDLES[this.viewId]()

      if (this.stopMarkers.length > 0) this.showTransitStops()
    },

    // 'globalState.colorScheme'() {
    //   // change one element to force a deck.gl redraw
    //   this.$nextTick().then(p => {
    //     // const tooltips = this.vizDetails. || []
    //     // this.vizDetails.tooltip = [...tooltips]
    //   })
    // },

    searchText() {
      this.debounceHandleSearchText()
    },

    '$store.state.colorScheme'() {
      this.isDarkMode = this.$store.state.colorScheme === ColorScheme.DarkMode
      this.highlightAllAttachedRoutes()
    },
  },

  methods: {
    async updatePieSlider() {
      if (!this.stopMarkers.length) return

      const z = [...this.stopMarkers]
      this.stopMarkers = []
      // this allows deck.gl to wake up and redraw
      await new Promise(resolve => {
        setTimeout(() => {
          resolve(true)
        }, 1)
      })
      this.stopMarkers = z
      await this.$nextTick()

      // this.stopMarkers = [...this.stopMarkers]
    },

    handleMapClick(e: any) {
      if (e.index > -1) {
        // clicked on a thing
        this.clickedOnTransitLink(e.index)
      } else {
        // empty map click
        this.handleEmptyClick(true, false)
      }
    },

    incrementLoadProgress() {
      this.loadSteps += 1
      this.loadProgress = (100 * this.loadSteps) / this.totalLoadSteps
    },

    handleSearchText() {
      this.handleEmptyClick(null, true)
      this.selectedLinkId = ''

      let foundRoutes = [] as any[]
      const searchTerm = this.searchText.trim().toLocaleLowerCase()

      if (!searchTerm) {
        this.resetLinkColors()
        return
      }

      foundRoutes = Object.keys(this._routeData).filter(
        routeID => routeID.toLocaleLowerCase().indexOf(searchTerm) > -1
      )

      // show selected routes
      this.routesOnLink = foundRoutes.map(id => this._routeData[id])

      this.highlightAllAttachedRoutes()
    },

    hoverOverStop(stop: any, e: MouseEvent) {
      this.stopHTML.html = ''
      const lines = [] as string[]
      if (stop.name) lines.push(`<b>${stop.name}</b>`)
      for (const attr of ['id', 'linkRefId']) {
        if (stop[attr]) lines.push(`${attr}: ${stop[attr]}`)
      }
      this.stopHTML.html = '<p>' + lines.join('<br/>') + '</p>'
      this.stopHTML.x = stop.xy.x + 8
      this.stopHTML.y = stop.xy.y - 36
    },

    dividerDragStart(e: MouseEvent) {
      console.log('dragstart')
      // console.log('dragStart', e)
      this.isDraggingDivider = e.clientX
      this.dragStartWidth = this.legendSectionWidth
    },

    dividerDragEnd(e: MouseEvent) {
      this.isDraggingDivider = 0
    },

    dividerDragging(e: MouseEvent) {
      if (!this.isDraggingDivider) return

      const deltaX = this.isDraggingDivider - e.clientX
      this.legendSectionWidth = Math.max(0, this.dragStartWidth + deltaX)
    },

    async getVizDetails() {
      // are we in a dashboard?
      if (this.config) {
        this.vizDetails = Object.assign({}, this.config)
        return true
      }

      // if a YAML file was passed in, just use it
      if (this.myState.yamlConfig?.endsWith('yaml') || this.myState.yamlConfig?.endsWith('yml')) {
        return this.loadYamlConfig()
      }

      // Build the config based on folder contents
      const title = this.myState.yamlConfig.substring(
        0,
        15 + this.myState.yamlConfig.indexOf('transitSchedule')
      )

      this.vizDetails = {
        transitSchedule: this.myState.yamlConfig,
        network: '',
        title,
        description: '',
        demand: '',
        projection: '',
        customRouteTypes: [],
      }

      this.$emit('title', title)
      return true
    },

    async prepareView() {
      const { files } = await this.fileApi.getDirectory(this.myState.subfolder)

      let network = this.vizDetails.network
      // First see if we have an avro network
      if (!network) {
        const avroFilename =
          this.myState.yamlConfig.substring(
            0,
            this.myState.yamlConfig.indexOf('transitSchedule.')
          ) + 'network.avro'
        if (files.indexOf(avroFilename) > -1) network = avroFilename
      }

      // Try the most obvious network filename:

      if (!network) network = this.myState.yamlConfig.replaceAll('transitSchedule', 'network')

      // if the obvious network file doesn't exist, just grab... the first network file:
      if (files.indexOf(network) == -1) {
        const allNetworks = files.filter(f => f.endsWith('network.xml.gz'))
        if (allNetworks.length) network = allNetworks[0]
        else {
          this.loadingText = 'No road network found.'
          network = ''
        }
      }

      // Departures: use them if we are in an output folder (and they exist)
      let demandFiles = [] as string[]
      if (this.myState.yamlConfig.indexOf('output_transitSchedule') > -1) {
        demandFiles = files.filter(f => f.endsWith('pt_stop2stop_departures.csv.gz'))
      }

      // Save everything
      this.vizDetails.network = network
      if (demandFiles.length) this.vizDetails.demand = demandFiles[0]
    },

    async guessProjection(networks: any): Promise<string> {
      // 00. If it's in config, use it
      if (this.vizDetails.projection) return this.vizDetails.projection
      if (this.config?.projection) return this.config.projection

      // 0. If it's in the AVRO network, use it
      if (networks?.roadXML?.attributes?.coordinateReferenceSystem) {
        return networks?.roadXML?.attributes?.coordinateReferenceSystem
      }

      // 0. If it's in the network, use it
      if (networks?.roadXML?.network?.attributes?.attribute?.name === 'coordinateReferenceSystem') {
        return networks?.roadXML?.network?.attributes?.attribute['#text']
      }

      // 1. if we have it in storage already, use it
      const storagePath = `${this.root}/${this.subfolder}`
      let savedConfig = undefined // localStorage.getItem(storagePath) as any

      const goodEPSG = /EPSG:.\d/

      if (savedConfig) {
        try {
          const config = JSON.parse(savedConfig)

          if (goodEPSG.test(config.networkProjection)) {
            return config.networkProjection
          } else {
            savedConfig = {}
          }
        } catch (e) {
          console.error('bad saved config in storage', savedConfig)
          savedConfig = {}
          // fail! ok try something else
        }
      }

      // 2. try to get it from config
      const { files } = await this.fileApi.getDirectory(this.myState.subfolder)
      const outputConfigs = files.filter(
        f => f.indexOf('.output_config.xml') > -1 || f.indexOf('.output_config_reduced.xml') > -1
      )
      if (outputConfigs.length && this.fileSystem) {
        // console.log('trying to find CRS in', outputConfigs[0])

        for (const xmlConfigFileName of outputConfigs) {
          try {
            const configXML: any = await this.fetchXML({
              worker: null,
              slug: this.fileSystem.slug,
              filePath: this.myState.subfolder + '/' + xmlConfigFileName,
            })

            const global = configXML.config.module.filter((f: any) => f.$name === 'global')[0]
            const crs = global.param.filter((p: any) => p.$name === 'coordinateSystem')[0]

            const crsValue = crs.$value

            // save it
            // savedConfig = savedConfig || {}
            // savedConfig.networkProjection = crsValue
            // localStorage.setItem(storagePath, JSON.stringify(savedConfig))
            return crsValue
          } catch (e) {
            console.warn('Failed parsing', xmlConfigFileName)
          }
        }
      }

      // 3. ask the user
      let entry = prompt('Need coordinate EPSG number:', '') || ''

      // if user cancelled, give up
      if (!entry) return ''
      // if user gave bad answer, try again
      if (Number.isNaN(parseInt(entry, 10)) && !goodEPSG.test(entry))
        return this.guessProjection(networks)

      // hopefully user gave a good EPSG number
      if (!entry.startsWith('EPSG:')) entry = 'EPSG:' + entry

      const networkProjection = entry
      localStorage.setItem(storagePath, JSON.stringify({ networkProjection }))
      return networkProjection
    },

    async loadYamlConfig() {
      const filename =
        this.myState.yamlConfig.indexOf('/') > -1
          ? this.myState.yamlConfig
          : this.myState.subfolder + '/' + this.myState.yamlConfig

      try {
        const text = await this.fileApi.getFileText(filename)
        this.vizDetails = yaml.parse(text)
      } catch (e) {
        // maybe it failed because password?
        const err = e as any
        if (this.fileSystem && this.fileSystem.needPassword && err.status === 401) {
          this.$store.commit('requestLogin', this.fileSystem.slug)
        } else {
          const msg = 'Could not load ' + filename
          this.$emit('error', msg)
          this.loadingText = msg
        }
        return false
      }

      const t = this.vizDetails.title ? this.vizDetails.title : 'Transit Ridership'
      this.$emit('title', t)

      this.projection = this.vizDetails.projection
      return true
    },

    isMobile() {
      const w = window
      const d = document
      const e = d.documentElement
      const g = d.getElementsByTagName('body')[0]
      const x = w.innerWidth || e.clientWidth || g.clientWidth
      const y = w.innerHeight || e.clientHeight || g.clientHeight
      return x < 640
    },

    setupMap() {
      try {
        const extent = localStorage.getItem(this.$route.fullPath + '-bounds')

        if (extent) {
          try {
            const lnglat = JSON.parse(extent)
            const mFac = this.isMobile() ? 0 : 1
            const padding = { top: 50 * mFac, bottom: 50 * mFac, right: 50 * mFac, left: 50 * mFac }
          } catch (e) {
            // ignore this, it's ok
          }
        }
      } catch (e) {
        console.warn('' + e)

        // no worries
      }
    },

    drawMetric() {
      let widthExpression: any = 3

      this.transitLinks.features.forEach((link: any) => {
        let width = 1
        switch (this.activeMetric) {
          case 'departures':
            width = link.properties.departures * 0.025
            break
          case 'pax':
            width = link.properties.pax * 0.0015
            break
          case 'loadfac':
            width = link.properties.loadfac * 200
            break
        }
        link.properties.width = width
      })

      this.transitLinks = { ...this.transitLinks }
    },

    handleClickedMetric(metric: { field: string }) {
      console.log('metric:', metric.field)
      this.activeMetric = metric.field
      this.drawMetric()
    },

    handleEmptyClick(e: any, force?: boolean) {
      // this is here because zeroing out the search box also cascades the zeroing out
      // of our selected link. Bad!
      if (!e && this.isHighlightingLink) {
        this.isHighlightingLink = false
        return
      }

      this.isHighlightingLink = false

      // clear search box if user clicked away
      if (!force) this.searchText = ''

      // don't clear map if search box has text
      if (this.searchText && !force) return

      this.removeStopMarkers()
      this.removeSelectedRoute()
      this.resetLinkColors()

      this.routesOnLink = []
      this.stopHTML.html = ''
      this.summaryStats = { departures: 0, pax: 0, loadfac: 0 }

      this.transitLinks = { ...this.transitLinks }
    },

    async loadEverything() {
      const networks = await this.loadNetworks()
      const projection = await this.guessProjection(networks)
      this.vizDetails.projection = projection
      this.projection = this.vizDetails.projection

      if (networks) this.processInputs(networks)

      // TODO remove for now until we research whether this causes a memory leak:
      // this.setupKeyListeners()
    },

    setupKeyListeners() {
      window.addEventListener('keyup', event => {
        if (event.keyCode === 27) {
          // ESC
          this.pressedEscape()
        }
      })
      window.addEventListener('keydown', event => {
        if (event.keyCode === 38) {
          this.pressedArrowKey(-1) // UP
        }
        if (event.keyCode === 40) {
          this.pressedArrowKey(+1) // DOWN
        }
      })
    },

    fetchXML(props: { worker: any; slug: string; filePath: string; options?: any }) {
      let xmlWorker = props.worker

      xmlWorker.onmessage = (message: MessageEvent) => {
        // message.data will have .id and either .error or .xml
        const { resolve, reject } = this.resolvers[message.data.id]

        xmlWorker.terminate()

        if (message.data.error) reject(message.data.error)
        resolve(message.data.xml)
      }

      // save the promise by id so we can look it up when we get messages
      const id = this.resolverId++

      xmlWorker.postMessage({
        id,
        fileSystem: this.fileSystem,
        filePath: props.filePath,
        options: props.options,
      })

      const promise = new Promise((resolve, reject) => {
        this.resolvers[id] = { resolve, reject }
      })
      return promise
    },

    async updateStatus(message: string) {
      this.loadingText = message
    },

    async loadAvroRoadNetwork() {
      console.log('LOADING AVRO:', this.vizDetails.network)
      const filename = `${this.subfolder}/${this.vizDetails.network}`
      const blob = await this.fileApi.getFileBlob(filename)

      const records: any[] = await new Promise((resolve, reject) => {
        const rows = [] as any[]
        avro
          .createBlobDecoder(blob)
          .on('metadata', (schema: any) => {
            // console.log(schema)
          })
          .on('data', (row: any) => {
            rows.push(row)
          })
          .on('end', () => {
            resolve(rows)
          })
      })

      // console.log({ records })
      this.avroNetwork = records[0]
      return records[0]
    },

    async loadNetworks() {
      try {
        if (!this.fileSystem || !this.vizDetails.network || !this.vizDetails.transitSchedule) return

        this.loadingText = 'Loading networks...'
        this.incrementLoadProgress()

        const filename = this.vizDetails.network

        const roads =
          filename.indexOf('.avro') > -1
            ? // AVRO networks have a separate reader:
              this.loadAvroRoadNetwork()
            : // normal MATSim network
              this.fetchXML({
                worker: this._roadFetcher,
                slug: this.fileSystem.slug,
                filePath: this.myState.subfolder + '/' + this.vizDetails.network,
                options: { attributeNamePrefix: '' },
              })

        const transit = this.fetchXML({
          worker: this._transitFetcher,
          slug: this.fileSystem.slug,
          filePath: this.myState.subfolder + '/' + this.vizDetails.transitSchedule,
          options: {
            attributeNamePrefix: '',
            alwaysArray: [
              'transitSchedule.transitLine.transitRoute',
              'transitSchedule.transitLine.transitRoute.departures.departure',
            ],
          },
        })

        // and wait for them to all complete
        const results = await Promise.all([roads, transit])
        return { roadXML: results[0], transitXML: results[1], ridership: [] }
      } catch (e) {
        console.error('TRANSIT:', e)
        this.loadingText
        this.$emit('error', '' + e)
        return null
      }
    },

    loadDemandData(filename: string): Promise<any[]> {
      this.totalLoadSteps += 3
      this.loadingText = 'Loading demand...'

      const promise: Promise<any[]> = new Promise<any[]>((resolve, reject) => {
        if (!filename) resolve([])
        this.incrementLoadProgress()

        const worker = new GzipWorker() as Worker

        worker.onmessage = (event: MessageEvent) => {
          this.loadingText = 'Processing demand...'
          this.incrementLoadProgress()

          worker.terminate()

          if (event.data.error) {
            this.$emit('error', event.data.error)
            this.loadingText = ''
            return
          }

          const csvData = new TextDecoder('utf-8').decode(event.data)

          Papa.parse(csvData, {
            // preview: 10000,
            header: true,
            skipEmptyLines: true,
            dynamicTyping: false,
            worker: true,
            complete: (results: any) => {
              const result = this.processDemand(results)
              resolve(result)
            },
          })
        }

        worker.postMessage({
          filePath: this.myState.subfolder + '/' + filename,
          fileSystem: this.fileSystem,
        })
      })
      return promise
    },

    processDemand(results: any) {
      // todo: make sure meta contains fields we need!
      this.loadingText = 'Summarizing demand data...'
      this.incrementLoadProgress()

      const numericCols = [
        'passengersAtAlighting',
        'passengersAtArrival',
        'passengersBoarding',
        'stopSequence',
        'totalVehicleCapacity',
      ]
      results.data.forEach((row: any) => {
        for (const key of numericCols) row[key] = parseFloat(row[key])
      })

      // build TWO crossfilters so memory doesn't freak out
      const midpoint = Math.floor(results.data.length / 2)
      const data1 = results.data.slice(0, midpoint)
      const data2 = results.data.slice(midpoint)

      // everything is doubled because crossfilter fails above ~1million rows
      // splitting the dataset into halves gets us to ~2million...
      this.cfDemand1 = crossfilter(data1)
      this.cfDemand2 = crossfilter(data2)
      this.cfDemandLink1 = this.cfDemand1.dimension((d: any) => d.linkIdsSincePreviousStop)
      this.cfDemandLink2 = this.cfDemand2.dimension((d: any) => d.linkIdsSincePreviousStop)

      // stop-level demand
      console.log('STOPSS')
      const dimStop1 = this.cfDemand1.dimension((d: any) => d.stop)
      const dimStop2 = this.cfDemand2.dimension((d: any) => d.stop)

      const stop1 = dimStop1.group()
      const stop2 = dimStop2.group()
      stop1
        .reduceSum((d: any) => d.passengersBoarding)
        .all()
        .map(row => {
          if (Number.isFinite(row.value))
            this.stopLevelDemand[row.key as any] = { b: row.value as number, a: 0 }
        })
      stop2
        .reduceSum((d: any) => d.passengersBoarding)
        .all()
        .map(row => {
          if (!this.stopLevelDemand[row.key as any])
            this.stopLevelDemand[row.key as any] = { b: 0, a: 0 }
          if (Number.isFinite(row.value))
            this.stopLevelDemand[row.key as any].b += row.value as number
        })
      stop1
        .reduceSum((d: any) => d.passengersAlighting)
        .all()
        .map(row => {
          if (!this.stopLevelDemand[row.key as any])
            this.stopLevelDemand[row.key as any] = { b: 0, a: 0 }
          if (Number.isFinite(row.value))
            this.stopLevelDemand[row.key as any].a += row.value as number
        })
      stop2
        .reduceSum((d: any) => d.passengersAlighting)
        .all()
        .map(row => {
          if (!this.stopLevelDemand[row.key as any])
            this.stopLevelDemand[row.key as any] = { b: 0, a: 0 }
          if (Number.isFinite(row.value))
            this.stopLevelDemand[row.key as any].a += row.value as number
        })
      dimStop1.dispose()
      dimStop2.dispose()

      // console.log(this.stopLevelDemand)
      console.log('STOPSS DONE --------')

      // build link-level passenger ridership ----------
      const linkPassengersById = {} as any

      const group1 = this.cfDemandLink1.group()
      const group2 = this.cfDemandLink2.group()

      // pax ridership
      group1
        .reduceSum((d: any) => d.passengersAtArrival)
        .all()
        .map(link => {
          linkPassengersById[link.key as any] = link.value
        })
      group2
        .reduceSum((d: any) => d.passengersAtArrival)
        .all()
        .map(link => {
          if (!linkPassengersById[link.key as any]) linkPassengersById[link.key as any] = link.value
          linkPassengersById[link.key as any] += link.value
        })

      // veh capacities
      const capacity = {} as any
      group1
        .reduceSum((d: any) => d.totalVehicleCapacity)
        .all()
        .map(link => {
          capacity[link.key as any] = link.value
        })
      group2
        .reduceSum((d: any) => d.totalVehicleCapacity)
        .all()
        .map(link => {
          if (!capacity[link.key as any]) capacity[link.key as any] = link.value
          capacity[link.key as any] += link.value
        })

      // update passenger value in the transit-link geojson.
      for (const transitLink of this.transitLinks.features) {
        if (!transitLink.properties) transitLink.properties = {}
        transitLink.properties['pax'] = linkPassengersById[transitLink.properties.id]
        transitLink.properties['cap'] = capacity[transitLink.properties.id]
        transitLink.properties['loadfac'] =
          Math.round(
            (1000 * linkPassengersById[transitLink.properties.id]) /
              capacity[transitLink.properties.id]
          ) / 1000
      }

      this.metrics = this.metrics.concat([
        { field: 'pax', name_en: 'Passengers', name_de: 'Passagiere' },
        { field: 'loadfac', name_en: 'Load Factor', name_de: 'Auslastung' },
      ])

      this.loadProgress = 100
      return []
    },

    async processInputs(networks: NetworkInputs) {
      this.loadingText = 'Examining networks...'
      this.incrementLoadProgress()

      // spawn transit helper web worker
      this._transitHelper = new TransitSupplyWorker()

      this._transitHelper.onmessage = async (buffer: MessageEvent) => {
        this.receivedProcessedTransit(buffer)
      }

      this._transitHelper.postMessage({
        xml: networks,
        projection: this.projection,
      })
    },

    async receivedProcessedTransit(buffer: MessageEvent) {
      if (buffer.data.status) {
        this.loadingText = buffer.data.status
        this.incrementLoadProgress()
        return
      }

      if (buffer.data.error) {
        console.error(buffer.data.error)
        this.$emit('error', '' + buffer.data.error)
        this.loadingText = ''
        return
      }

      const { network, routeData, stopFacilities, transitLines, mapExtent } = buffer.data

      this._network = network
      this._routeData = routeData
      this._stopFacilities = stopFacilities
      this.transitLines = transitLines
      this._mapExtentXYXY = mapExtent

      this._transitHelper.terminate()

      this.loadingText = 'Summarizing departures...'
      this.incrementLoadProgress()

      // Use custom colors if they exist, otherwise use defaults
      if (this.vizDetails.customRouteTypes && this.vizDetails.customRouteTypes.length > 0) {
        this.routeColors = this.vizDetails.customRouteTypes
      } else {
        this.routeColors = DEFAULT_ROUTE_COLORS
      }

      await this.processDepartures()

      // Build the links layer and add it
      this.transitLinks = await this.constructDepartureFrequencyGeoJson()
      this.transitLinkOffset = {}
      this.transitLinks.features.forEach((feature: any, i: number) => {
        //@ts-ignore
        this.transitLinkOffset[feature.properties.id] = i
      })

      this._geoTransitLinks = this.transitLinks

      this.drawMetric()

      this.handleClickedMetric({ field: 'departures' })

      localStorage.setItem(this.$route.fullPath + '-bounds', JSON.stringify(this._mapExtentXYXY))

      if (this.vizDetails.demand) await this.loadDemandData(this.vizDetails.demand)

      this.loadingText = ''
    },

    visualSortTransitLinks() {
      // sort by importance:
      // 0=grey 1=routecolor 2=highlightedroute 3=selectedroute 4=selectedlink

      //@ts-ignore
      this.transitLinks.features.sort((a, b) => (a.properties.sort < b.properties.sort ? -1 : 1))

      // recalc offsets
      this.transitLinkOffset = {}
      this.transitLinks.features.forEach((feature: any, i: number) => {
        //@ts-ignore
        this.transitLinkOffset[feature.properties.id] = i
      })
      this.transitLinks = { ...this.transitLinks }
    },

    async processDepartures() {
      this.loadingText = 'Processing departures...'
      this.incrementLoadProgress()

      for (const transitLine of Object.values(this.transitLines)) {
        for (const route of transitLine.transitRoutes) {
          for (const linkID of route.route) {
            if (!(linkID in this._departures)) {
              this._departures[linkID] = { total: 0, routes: new Set() }
            }
            this._departures[linkID].total += route.departures
            this._departures[linkID].routes.add(route.id)
          }
        }
      }

      // get max so we can scale line widths nicely
      Object.values(this._departures).forEach(
        e => (this._maximum = Math.max(this._maximum, e.total))
      )
    },

    async constructDepartureFrequencyGeoJson() {
      const geojson = [] as any
      this.usedLabels = []

      for (const linkID in this._departures) {
        if (this._departures.hasOwnProperty(linkID)) {
          const link = this._network.links[linkID] as any
          if (link == undefined) continue

          let coordinates

          try {
            if (this.avroNetwork) {
              // link is an INDEX to the link column arrays
              const nodeFrom = this.avroNetwork.from[link]
              const nodeTo = this.avroNetwork.to[link]

              const coordsFrom = this.avroNetwork.__nodes[nodeFrom]
              const coordsTo = this.avroNetwork.__nodes[nodeTo]
              coordinates = [coordsFrom, coordsTo]
            } else {
              // link is an object with values
              coordinates = [
                [this._network.nodes[link.from].x, this._network.nodes[link.from].y],
                [this._network.nodes[link.to].x, this._network.nodes[link.to].y],
              ]
            }
          } catch (e) {
            console.warn('' + e)
            continue
          }

          const departures = this._departures[linkID].total

          const routes = [...this._departures[linkID].routes]
          // TODO for now take color from... first route?
          // for (const routeId of this._departures[linkID].routes) {
          const routeId = routes[0]

          const { color, hideThisLine } = this.determineRouteColor(routeId)

          let line = {
            type: 'Feature',
            geometry: {
              type: 'LineString',
              coordinates: coordinates,
            },
            properties: {
              ...this.$props,
              color,
              departures: departures,
              id: linkID,
              from: link.from,
              to: link.to,
              currentColor: color,
            },
          }

          line = this.offsetLineByMeters(line, 5)

          // Add the line to the geojson array only if the line should not be hidden
          if (!hideThisLine) geojson.push(line)
        }
      }

      return { type: 'FeatureCollection', features: geojson } as GeoJSON.FeatureCollection
    },

    determineRouteColor(id: string) {
      let color = '#888'
      let hideThisLine = false // stores if this line should be hidden from view

      const props = this._routeData[id] as any
      // routeColors is a list of possible matches by GTFS code, modestring, etc.
      // For each route, we loop through the list of metrics.  The first set of
      // match conditions that match all parameters determines the route color.
      for (const config of this.routeColors) {
        hideThisLine = false
        if (config.hide) hideThisLine = true

        let matched = true

        // loop through all parameters in this match definition
        for (const [key, pattern] of Object.entries(config.match) as any[]) {
          const valueForThisProp = props[key]
          // fail if route doesn't include this match property
          if (!valueForThisProp) {
            matched = false
            break
          }

          // because the gtfsRouteType is an integer or an integer array micromatch doesn't work
          if (key === 'gtfsRouteType') {
            if (Array.isArray(pattern)) {
              // array of gtfs values
              if (!pattern.includes(valueForThisProp)) {
                matched = false
                break
              }
            } else {
              // numeric - just one value
              if (valueForThisProp !== pattern) {
                matched = false
                break
              }
            }
          } else {
            // text-match the pattern
            if (!match.isMatch(valueForThisProp, pattern)) {
              matched = false
              break
            }
          }
        }
        // Set color and stop searching after first successful match
        // the label will only be added if the route should not be hidden
        if (matched) {
          color = config.color
          if (!this.usedLabels.includes(config.label) && !hideThisLine)
            this.usedLabels.push(config.label)
          break
        }
      }
      // no rules matched; sad!
      if (color == '#888') console.log('OHE NOES', id)

      return { color, hideThisLine }
    },

    offsetLineByMeters(line: any, metersToTheRight: number) {
      try {
        const offsetLine = turf.lineOffset(line, metersToTheRight, { units: 'meters' })
        return offsetLine
      } catch (e) {
        // offset can fail if points are exactly on top of each other; ignore.
      }
      return line
    },

    removeStopMarkers() {
      this.stopMarkers = []
      this.stopHTML.html = ''
    },

    toggleTransitLine(line: any) {
      line.isOpen = !line.isOpen

      if (line.isOpen) {
        // upon open, highlight ALL routes that are in this transit-line
        this.selectedTransitLine = line.id

        this.selectAllRoutesInLine(line)
      } else {
        // de-highlight upon closing
        this.selectedTransitLine = ''
        this.removeStopMarkers()
        this.removeSelectedRoute()
      }

      this.$forceUpdate()
    },

    selectAllRoutesInLine(line: { routes: RouteDetails[] }) {
      const selectedIds = line.routes.map(route => route.id)
      this.selectedRouteIds = selectedIds
      this.showTransitRoutes()
      this.showTransitStops()
    },

    showRouteDetails(routeID: string, numRoutes: number) {
      // special case: if ALL routes in the current line are selected, AND nothing else is selected,
      // AND the user just asked to remove "one" route, they probably want to see JUST that route
      if (numRoutes > 1 && this.selectedRouteIds.length == numRoutes) {
        this.selectedRouteIds = [routeID]
      } else {
        const shownRoutes = new Set(this.selectedRouteIds)
        if (shownRoutes.has(routeID)) shownRoutes.delete(routeID)
        else shownRoutes.add(routeID)
        this.selectedRouteIds = [...shownRoutes]
      }

      this.showTransitRoutes()
      this.showTransitStops()
    },

    showTransitStops() {
      const markers = {} as { [stopId: string]: any }

      const mapBearing = globalStore.state.viewState.bearing

      this.selectedRouteIds.forEach(routeId => {
        const route = this._routeData[routeId]

        const allStops = route.routeProfile
        const numStops = allStops.length
        // purposely unitialized so that final stop retains previous value
        let bearing

        for (const [i, stop] of allStops.entries()) {
          // figure out bearing direction for stop icon
          const startFacility = this._stopFacilities[stop.refId]
          const startCoord = turf.point([startFacility.x, startFacility.y])
          if (i < numStops - 1) {
            const endFacility = this._stopFacilities[route.routeProfile[i + 1].refId]
            const endCoord = turf.point([endFacility.x, endFacility.y])
            // so icons rotate along with map
            bearing = mapBearing - turf.bearing(startCoord, endCoord)
          }

          // every marker has a latlng coord and a bearing
          const marker = {
            i,
            bearing,
            xy: [startFacility.x, startFacility.y],
            name: startFacility.name || '',
            id: startFacility.id || '',
            linkRefId: startFacility.linkRefId || '',
          } as any

          // figure out boardings/alightings at each stop
          if (this.stopLevelDemand) {
            const ridership = this.stopLevelDemand[stop.refId]
            if (ridership) {
              marker.boardings = ridership.b
              marker.alightings = ridership.a
            }
          }

          markers[marker.id] = marker
        }
      })

      this.stopMarkers = Object.values(markers)
    },

    showTransitRoutes() {
      this.stopHTML.html = ''

      if (!this.selectedRouteIds.length) {
        this.removeSelectedRoute()
        this.removeStopMarkers()
        return
      }

      const featureCollection = [] as any[]

      this.selectedRouteIds.forEach(id => {
        const route = this._routeData[id]
        featureCollection.push(route.geojson)
      })

      this.selectedFeatures = featureCollection
    },

    removeSelectedRoute() {
      this.selectedFeatures = []
      this.selectedRouteIds = []
    },

    clickedOnTransitLink(index: number) {
      this.isHighlightingLink = true
      this.removeStopMarkers()
      this.removeSelectedRoute()

      // the browser delivers some details that we need, in the fn argument 'e'
      const props = this.transitLinks.features[index].properties

      this.selectedLinkId = props.id
      const routeIDs = this._departures[props.id].routes

      // overall link statistics
      let empty = { departures: 0, pax: 0, loadfac: 0 }
      const found = this.transitLinks.features.find((link: any) => link.properties.id == props.id)
      this.summaryStats = found ? found.properties : empty

      // routes on this link
      const routes = []
      for (const id of routeIDs) {
        const details = this._routeData[id]
        details.color = props.color
        details.currentColor = props.color
        routes.push(details)
      }

      // sort by highest departures first
      routes.sort(function (a, b) {
        return a.departures > b.departures ? -1 : 1
      })

      this.routesOnLink = routes

      // highlight selected routes
      this.highlightAllAttachedRoutes()

      // and select the first highlighted route
      // if (routes.length > 0) this.showRouteDetails(routes[0].id)
    },

    resetLinkColors(color?: string) {
      if (color) {
        for (const link of this.transitLinks.features) {
          link.properties.currentColor = color
          link.properties.sort = 0
        }
      } else {
        for (const link of this.transitLinks.features) {
          link.properties.currentColor = link.properties.color
          link.properties.sort = 0
        }
      }
    },

    highlightAllAttachedRoutes() {
      if (!this.transitLinks) return

      const gray = this.isDarkMode ? '#444455' : '#ccccdd'
      this.resetLinkColors(gray)

      for (const routeDetails of this.routesOnLink) {
        for (const linkId of routeDetails.route) {
          const offset = this.transitLinkOffset[linkId]
          const transitLink = this.transitLinks.features[offset]
          transitLink.properties.currentColor = transitLink.properties.color
          transitLink.properties.sort = 2
        }
      }

      // selected link all the way on top
      if (this.selectedLinkId) {
        const selectedLink = this.transitLinks.features[this.transitLinkOffset[this.selectedLinkId]]
        selectedLink.properties.currentColor = '#f0f'
        selectedLink.properties.sort = 4
      }

      // sort by visual importance
      this.visualSortTransitLinks()

      this.transitLinks = { ...this.transitLinks }
    },

    pressedEscape() {
      console.log('ESC')
      this.removeSelectedRoute()
      this.removeStopMarkers()
      this.resetLinkColors()
      this.routesOnLink = []
    },

    pressedArrowKey(delta: number) {
      return
      // if (!this.selectedRouteIds.length) return

      // let i = this.routesOnLink.indexOf(this.selectedRoute)
      // i = i + delta

      // if (i < 0 || i >= this.routesOnLink.length) return

      // this.showRouteDetails(this.routesOnLink[i].id)
    },

    clearData() {
      this._departures = {}
      this._mapExtentXYXY = [180, 90, -180, -90]
      this._maximum = 0
      this._network = { nodes: {}, links: {} }
      this._routeData = {}
      this._stopFacilities = {}
      this.transitLinks = { type: 'FeatureCollection', features: [] }
      this.transitLines = {}
      this.selectedRouteIds = []
      this.cfDemand1 = null
      this.cfDemand2 = null
      this.cfDemandLink1?.dispose()
      this.cfDemandLink2?.dispose()
      this.cfDemandStop1?.dispose()
      this.cfDemandStop2?.dispose()
      this.resolvers = {}
      this.routesOnLink = []
      this.stopMarkers = []
      this._geoTransitLinks = null
    },
  },

  async mounted() {
    this.$store.commit('setFullScreen', !this.thumbnail)

    this.debounceHandleSearchText = debounce(this.handleSearchText, 350)
    this.clearData()

    this._roadFetcher = new NewXmlFetcher()
    this._transitFetcher = new NewXmlFetcher()
    this._transitHelper = new TransitSupplyWorker()

    // populate props after we attach, not before!
    this.myState.subfolder = this.subfolder
    this.myState.yamlConfig = this.yamlConfig ?? ''
    this.myState.thumbnail = this.thumbnail

    const status = await this.getVizDetails()
    if (!status) return

    if (this.thumbnail) return

    await this.prepareView()
    this.setupMap()
    this.loadEverything()
  },

  beforeDestroy() {
    this.clearData()

    if (this.xmlWorker) this.xmlWorker.terminate()
    if (this._roadFetcher) this._roadFetcher.terminate()
    if (this._transitFetcher) this._transitFetcher.terminate()
    if (this._transitHelper) this._transitHelper.terminate()

    this.$store.commit('setFullScreen', false)
  },
})

const _colorScale = colormap({ colormap: 'viridis', nshades: COLOR_CATEGORIES })

export default MyComponent
</script>

<style scoped lang="scss">
@import '@/styles.scss';

.mapboxgl-popup-content {
  padding: 0px 20px 0px 0px;
  opacity: 0.95;
  box-shadow: 0 0 3px #00000080;
}

h4,
p {
  margin: 0px 0px;
}

.transit-popup {
  padding: 0px 0px;
  margin: 0px 0px;
  border-style: solid;
  border-width: 0px 0px 0px 20px;
}

.transit-viz {
  position: relative;
  height: 100%;
  display: flex;
  flex-direction: column;
  min-height: $thumbnailHeight;
  background-size: cover;
}

.map-container {
  position: relative;
  flex: 1;
  background: url('assets/thumbnail.jpg') no-repeat;
  background-color: #eee;
  background-size: cover;
  min-height: $thumbnailHeight;
}

.hide-thumbnail {
  background: none;
  z-index: 0;
}

.legend {
  background-color: var(--bgPanel);
  padding: 0.25rem 0.5rem;
}

.route {
  padding: 5px 0px 5px 1.5rem;
  text-align: left;
  color: var(--text);
}

.route:hover {
  background-color: var(--bgCream3);
  cursor: pointer;
}

h3 {
  margin: 0px 0px;
  font-size: 1.5rem;
  line-height: 1.7rem;
}

.route-title {
  font-weight: bold;
  line-height: 1.2rem;
  margin: 0;
  color: var(--link);
}

.stopmarker {
  width: 12px;
  height: 12px;
  cursor: pointer;
}

.stop-marker-big {
  background: url('assets/icon-stop-triangle.png') no-repeat;
  background-size: 100%;
  width: 16px;
  height: 16px;
}

.highlightedRoute {
  background-color: #faffae;
  color: black;
}

.highlightedRoute:hover {
  background-color: #faffae;
}

.bigtitle {
  font-weight: bold;
  font-style: italic;
  font-size: 20px;
  margin: 20px 0px;
}

.info-header {
  text-align: center;
  background-color: #097c43;
  padding: 0.5rem 0rem;
  border-top: solid 1px #888;
  border-bottom: solid 1px #888;
}

.project-summary-block {
  width: 16rem;
  grid-column: 1 / 2;
  grid-row: 1 / 2;
  margin: 0px auto auto 0px;
  z-index: 10;
}

@keyframes slideInFromLeft {
  from {
    transform: translateX(-100%);
  }
  to {
    transform: translateX(0);
  }
}

.stop-html {
  position: absolute;
  top: 0;
  left: 0;
  background-color: var(--bgPanel);
  padding: 0.25rem;
  line-height: 1.1rem;
  z-index: 2;
}

.stop-marker {
  position: absolute;
  width: 12px;
  height: 12px;
  background: url('assets/icon-stop-triangle.png') no-repeat;
  transform: translate(-50%, -50%);
  background-size: 100%;
  // pointer-events: none;
  z-index: 1;
  cursor: pointer;
}

.help-text {
  color: #ccc;
}

.panel-items {
  color: var(--text);
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  // position: relative;
  margin: 0;
  font-size: 0.9rem;
}

.panel-item {
  display: flex;
  flex-direction: column;

  h3 {
    padding: 0.5rem 1rem 1.5rem 0.5rem;
  }
}

.route-list {
  position: absolute;
  top: 0;
  bottom: 0;
  user-select: none;
  overflow-x: hidden;
  cursor: pointer;
  scrollbar-color: #888 var(--bgCream);
  -webkit-scrollbar-color: #888 var(--bgCream);
  width: 100%;

  h3 {
    font-size: 1.2rem;
  }
}

.dashboard-panel {
  display: flex;
  flex-direction: column;
}

.metric-buttons {
  display: flex;
  flex-direction: row;
  gap: 0px;
  margin: 0.25rem 0.5rem 0.25rem 0;
}

.metric-button {
  border-radius: 0;
  flex: 1;
}

.detailed-route-data {
  display: flex;
  flex-direction: row;
  color: #666;
  font-weight: normal;
  gap: 0.5rem;
}

.col {
  display: flex;
  flex-direction: column;
  line-height: 1.1rem;
  color: #666;
}

.map-styles {
  height: 100%;
}

.status-corner {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 15;
  display: flex;
  flex-direction: column;
  background-color: var(--bgPanel);
  padding: 0.5rem 3rem;
  margin: auto auto;
  width: 25rem;
  height: 5rem;
  border: 3px solid #cccccc80;
  // filter: $filterShadow;

  a {
    color: white;
    text-decoration: none;

    &.router-link-exact-active {
      color: white;
    }
  }

  p {
    color: var(--textFancy);
    font-weight: normal;
    font-size: 1.3rem;
    line-height: 1rem;
    margin: auto 0;
    padding: 0 0;
    text-align: center;
  }
}

.main-layout {
  display: grid;
  // one unit, full height/width. Layers will go on top:
  grid-template-rows: 1fr;
  grid-template-columns: 1fr auto auto;
  min-height: $thumbnailHeight;
  height: 100%;
  background-color: var(--bg);
}

.map-layout.hide-thumbnail {
  background: unset;
  z-index: 0;
}

.area-map {
  grid-row: 1 / 2;
  grid-column: 1 / 2;
  background-color: var(--bgBold);
  position: relative;
}

.map-layers {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
}

.dragger {
  grid-row: 1 / 2;
  grid-column: 2 / 3;
  width: 0.5rem;
  background-color: var(--bgBold);
  user-select: none;
  z-index: 20;
}

.dragger:hover,
.dragger:active {
  background-color: var(--sliderThumb);
  transition: background-color 0.3s ease;
  transition-delay: 0.1s;
  cursor: ew-resize;
}

.link-summary {
  margin-bottom: 1rem;
  margin-right: 0.5rem;
  // border: 1px solid #80808066;
  // padding: 0.25rem;
}

.searchbox {
  margin-top: 0.25rem;
}

.load-progress {
  padding: 0 5rem;
  height: 3px;
  margin-top: 0rem;
}

.new-rightside-info-panel {
  grid-row: 1 / 2;
  grid-column: 3 / 4;
  display: flex;
  flex-direction: column;
  background-color: var(--bgCardFrame);

  .legend {
    margin: 0.5rem 0.25rem 0.25rem 0rem;
    display: flex;
    flex-direction: column;
    background-color: var(--bgCardFrame);
    border: 1px solid #88888844;
    .description {
      margin-top: 0.5rem;
    }
  }

  .tooltip-html {
    font-size: 0.8rem;
    padding: 0.25rem;
    text-align: left;
    background-color: var(--bgCardFrame);
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    border-top: 1px solid #88888880;
  }
}

.transit-lines {
  overflow-x: hidden;
  cursor: pointer;
  scrollbar-color: #888 var(--bgCream);
  -webkit-scrollbar-color: #888 var(--bgCream);
  width: 100%;

  h3 {
    font-size: 1.2rem;
  }
}

.transit-line {
  .line-header {
    padding: 0.5rem 0.5rem;
    background-color: var(--bgPanel3);
    font-weight: bold;
    font-size: 1.1rem;
    margin: 1px;
  }
  .stats {
    gap: 0.5rem;
    background-color: var(--bgPanel3);
    font-size: 0.9rem;
    font-weight: normal;
  }
}

.pie-slider {
  width: 10rem;
  padding: 1rem;
  margin: 0 auto;
  z-index: 10000;
}
</style>
